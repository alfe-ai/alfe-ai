<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Task Queue</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>

<div id="controls">
  <label><input type="checkbox" id="showHidden" /> Show hidden tasks</label>
  <label style="margin-left:1rem;">Project:
    <select id="projectFilter"><option value="">All projects</option></select>
  </label>
  <label style="margin-left:1rem;">Sprint:
    <select id="sprintFilter"><option value="">All sprints</option></select>
  </label>
  <button id="addTaskBtn">‚ûï New Task</button>
  <button id="instrBtn" title="Agent instructions">üìù</button>
  <button id="gearBtn" title="Configure columns">‚öôÔ∏è</button>
  <button id="defaultsBtn" title="Default project/sprint">‚≠ê</button>
  <button id="repoBtn" title="Edit Git repository">üîÄ</button>
  <button id="toggleTasksBtn">Hide tasks</button>
</div>

<table id="tasks">
  <thead><tr id="headerRow"></tr></thead>
  <tbody></tbody>
</table>

<!-- Column picker modal -->
<div id="colModal" class="modal">
  <div class="modal-content">
    <h2>Columns</h2>
    <div id="colList"></div>
    <div class="modal-buttons">
      <button id="colSaveBtn">Save</button>
      <button id="colCancelBtn">Cancel</button>
    </div>
  </div>
</div>

<!-- Agent instructions modal -->
<div id="instrModal" class="modal">
  <div class="modal-content">
    <h2>Agent Instructions</h2>
    <textarea id="instrText" rows="10" style="width:100%;"></textarea>
    <div class="modal-buttons">
      <button id="instrSaveBtn">Save</button>
      <button id="instrCancelBtn">Cancel</button>
    </div>
  </div>
</div>

<!-- Git repo modal -->
<div id="repoModal" class="modal">
  <div class="modal-content">
    <h2>Edit Git repository</h2>
    <label>Repository (owner/repo):
      <input type="text" id="repoInput" style="width:100%;" />
    </label>
    <div class="modal-buttons">
      <button id="repoSaveBtn">Save</button>
      <button id="repoCancelBtn">Cancel</button>
    </div>
  </div>
</div>

<!-- Defaults modal -->
<div id="defaultsModal" class="modal">
  <div class="modal-content">
    <h2>Default project / sprint</h2>
    <label>Default project:
      <input type="text" id="defProjectInput" style="width:100%;" />
    </label>
    <label>Default sprint:
      <input type="text" id="defSprintInput" style="width:100%;" />
    </label>
    <div class="modal-buttons">
      <button id="defSaveBtn">Save</button>
      <button id="defCancelBtn">Cancel</button>
    </div>
  </div>
</div>

<!-- New Task modal -->
<div id="newTaskModal" class="modal">
  <div class="modal-content">
    <h2>Create New Task</h2>
    <label>Title:<br/>
      <input type="text" id="newTaskTitle" style="width:100%;" />
    </label>
    <label style="margin-top:8px;">Description:<br/>
      <textarea id="newTaskBody" rows="5" style="width:100%;"></textarea>
    </label>
    <div class="modal-buttons">
      <button id="createTaskBtn">Create</button>
      <button id="cancelTaskBtn">Cancel</button>
    </div>
  </div>
</div>

<!-- Chat tabs area -->
<div id="chatTabs" style="display:flex; gap:0.5rem; align-items:center; margin-bottom:8px;">
  <div id="tabsContainer" style="flex-wrap: wrap; display: flex; gap: 0.5rem;"></div>
  <button id="newTabBtn">‚ûï Tab</button>
</div>

<!-- Chat panel -->
<div id="chatPanel">
  <!-- Model HUD -->
  <div id="modelHud" style="font-size:0.9rem; color:#555; margin-bottom:4px;"></div>
  <div id="chatMessages"></div>
  <div id="waitingCounter"></div>
  <input type="text" id="chatInput" placeholder="Type your message..." />
  <button id="chatSendBtn">Send</button>
</div>

<script>
  /* ---------------- default column definitions ---------------- */
  let columnsOrder = [
    { key: "drag",     label: "‚†ø"      },
    { key: "order",    label: "P"      },
    { key: "reorder",  label: "‚Üï"      },
    { key: "visibility", label: ""     },
    { key: "priority", label: "Prio"   },
    { key: "status",   label: "Status" },
    { key: "dependencies", label: "Depends On" },
    { key: "blocking", label: "Blocks" },
    { key: "slug",     label: "Slug"   },
    { key: "repo",     label: "Repo"   },
    { key: "number",   label: "#"      },
    { key: "title",    label: "Title"  },
    { key: "project",  label: "Project"},
    { key: "sprint",   label: "Sprint" },
    { key: "points",   label: "Pts"    },
    { key: "assignee", label: "Assignee"},
    { key: "created",  label: "Created"}
  ];
  let visibleCols = new Set(columnsOrder.map(c => c.key));
  let allTasks = [];
  let dragSrcRow = null;
  let modelName = "unknown";
  let tasksVisible = true;
  let chatTabs = [];
  let currentTabId = 1;

  const $  = (sel, ctx=document) => ctx.querySelector(sel);
  const $$ = (sel, ctx=document) => [...ctx.querySelectorAll(sel)];
  const isoDate = d => new Date(d).toLocaleDateString([], {year:"numeric",month:"2-digit",day:"2-digit"});

  function formatTimestamp(isoStr){
    if(!isoStr) return "(no time)";
    const d = new Date(isoStr);
    return d.toLocaleTimeString([], { hour12: false });
  }

  function showModal(m){ m.style.display = "flex"; }
  function hideModal(m){ m.style.display = "none"; }
  $$(".modal").forEach(m => m.addEventListener("click", e => { if(e.target===m) hideModal(m); }));

  /* ------------------------------------------------------------------
   * Toggling the task table
   * ------------------------------------------------------------------ */
  async function toggleTasks(){
    tasksVisible = !tasksVisible;
    $("#tasks").style.display = tasksVisible ? "" : "none";
    $("#toggleTasksBtn").textContent = tasksVisible ? "Hide tasks" : "Show tasks";
    // Save the setting
    await fetch("/api/settings", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ key: "tasks_visible", value: tasksVisible })
    });
  }
  $("#toggleTasksBtn").addEventListener("click", toggleTasks);

  /* ------------------------------------------------------------------
   * Load & save column config
   * ------------------------------------------------------------------ */
  async function loadSettings(){
    {
      const r = await fetch("/api/settings/visible_columns");
      if(r.ok){
        const { value } = await r.json();
        if(Array.isArray(value)){ visibleCols = new Set(value); }
      }
    }
    {
      const r = await fetch("/api/settings/columns_order");
      if(r.ok){
        const { value } = await r.json();
        if(Array.isArray(value)){
          const map = Object.fromEntries(columnsOrder.map(c=>[c.key,c]));
          const newOrd = [];
          value.forEach(k => { if(map[k]){ newOrd.push(map[k]); delete map[k]; }});
          Object.values(map).forEach(c => newOrd.push(c));
          columnsOrder = newOrd;
        }
      }
    }
    // Load tasks_visible setting
    {
      const r = await fetch("/api/settings/tasks_visible");
      if(r.ok){
        const { value } = await r.json();
        if(typeof value !== "undefined"){
          tasksVisible = !!value;
        }
      }
      $("#tasks").style.display = tasksVisible ? "" : "none";
      $("#toggleTasksBtn").textContent = tasksVisible ? "Hide tasks" : "Show tasks";
    }
  }
  async function saveSettings(){
    await fetch("/api/settings",{
      method:"POST",
      headers:{"Content-Type":"application/json"},
      body:JSON.stringify({ key:"visible_columns", value:[...visibleCols] })
    });
    await fetch("/api/settings",{
      method:"POST",
      headers:{"Content-Type":"application/json"},
      body:JSON.stringify({ key:"columns_order", value:columnsOrder.map(c=>c.key) })
    });
  }

  /* ------------------------------------------------------------------
   * Column rendering
   * ------------------------------------------------------------------ */
  function renderHeader(){
    const tr = $("#headerRow");
    tr.innerHTML = "";
    columnsOrder.forEach(col => {
      if(!visibleCols.has(col.key)) return;
      const th = document.createElement("th");
      th.textContent = col.label;
      tr.appendChild(th);
    });
  }

  /* ------------------------------------------------------------------
   * Drag & drop reordering
   * ------------------------------------------------------------------ */
  function handleDragStart(e){
    dragSrcRow = e.target.closest("tr");
    e.dataTransfer.effectAllowed = "move";
  }
  function handleDragOver(e){
    if(dragSrcRow && e.currentTarget !== dragSrcRow){
      e.preventDefault();
      e.dataTransfer.dropEffect = "move";
      e.currentTarget.classList.add("drag-over");
    }
  }
  function handleDragLeave(e){
    e.currentTarget.classList.remove("drag-over");
  }
  function handleDrop(e){
    e.preventDefault();
    const target = e.currentTarget;
    target.classList.remove("drag-over");
    if(dragSrcRow && dragSrcRow !== target){
      const tbody = target.parentNode;
      const rows = [...tbody.children];
      let from = rows.indexOf(dragSrcRow);
      let to = rows.indexOf(target);
      tbody.removeChild(dragSrcRow);
      if(from < to) to--;
      tbody.insertBefore(dragSrcRow, tbody.children[to]);
      saveNewOrderToServer();
    }
    dragSrcRow = null;
  }
  function handleDragEnd(e){
    $$(`tr.drag-over`).forEach(r=>r.classList.remove("drag-over"));
    dragSrcRow = null;
  }
  async function saveNewOrderToServer(){
    const ids = $$("#tasks tbody tr").map(r=>+r.dataset.taskId);
    await fetch("/api/tasks/reorderAll",{
      method:"POST",
      headers:{"Content-Type":"application/json"},
      body:JSON.stringify({ orderedIds: ids })
    });
  }

  /* ------------------------------------------------------------------
   * Fetch & render tasks
   * ------------------------------------------------------------------ */
  async function fetchTasks(){
    const inc = $("#showHidden").checked;
    const res = await fetch(`/api/tasks?includeHidden=${inc?1:0}`);
    return res.json();
  }
  function renderBody(){
    const tbody = $("#tasks tbody");
    tbody.innerHTML = "";
    const pj = $("#projectFilter").value;
    const sp = $("#sprintFilter").value;
    allTasks
            .filter(t=>{
              if(pj && t.project!==pj) return false;
              if(sp && t.sprint!==sp) return false;
              return true;
            })
            .forEach(t=>{
              const tr = document.createElement("tr");
              tr.dataset.taskId = t.id;
              if(t.hidden) tr.classList.add("hidden");
              [
                "drag","order","reorder","visibility","priority","status",
                "dependencies","blocking","slug","repo","number","title",
                "project","sprint","points","assignee","created"
              ].forEach(key=>{
                if(!visibleCols.has(key)) return;
                const td = document.createElement("td");
                switch(key){
                  case "drag":
                    td.innerHTML = `<span class="drag-handle" draggable="true">‚†ø</span>`;
                    td.querySelector(".drag-handle").addEventListener("dragstart", handleDragStart);
                    break;
                  case "order":
                    td.textContent = t.priority_number;
                    break;
                  case "reorder":
                    td.innerHTML = `<button class="arrow" data-id="${t.id}" data-dir="up">‚¨ÜÔ∏è</button>` +
                            `<button class="arrow" data-id="${t.id}" data-dir="down">‚¨áÔ∏è</button>`;
                    break;
                  case "visibility":
                    td.innerHTML = `<button class="eye" data-id="${t.id}">${t.hidden?"üôà":"üëÅÔ∏è"}</button>`;
                    break;
                  case "priority":
                    td.textContent = t.priority;
                    td.className="priority-cell";
                    break;
                  case "status":
                    td.textContent = t.status;
                    td.className="status-cell";
                    break;
                  case "dependencies":
                    td.textContent = t.dependencies;
                    td.className="dependencies-cell";
                    break;
                  case "blocking":
                    td.textContent = t.blocking;
                    td.className="blocking-cell";
                    break;
                  case "slug":
                    td.innerHTML = `<a href="${t.html_url}" target="_blank">${t.task_id_slug}</a>`;
                    break;
                  case "repo":
                    td.textContent = t.repository;
                    break;
                  case "number":
                    td.innerHTML = `<a href="${t.html_url}" target="_blank">#${t.number}</a>`;
                    break;
                  case "title":
                    td.textContent = t.title;
                    td.className="title-cell";
                    break;
                  case "project":
                    td.textContent = t.project;
                    td.className="project-cell";
                    break;
                  case "sprint":
                    td.textContent = t.sprint;
                    td.className="sprint-cell";
                    break;
                  case "points":
                    td.textContent = t.fib_points||"";
                    break;
                  case "assignee":
                    td.textContent = t.assignee||"";
                    break;
                  case "created":
                    td.textContent = isoDate(t.created_at);
                    break;
                  default:
                    td.textContent = t[key]||"";
                }
                tr.appendChild(td);
              });
              ["dragover","dragleave","drop","dragend"].forEach(evt=>{
                tr.addEventListener(evt, {
                  "dragover":handleDragOver,
                  "dragleave":handleDragLeave,
                  "drop":handleDrop,
                  "dragend":handleDragEnd
                }[evt]);
              });
              tbody.appendChild(tr);
            });
  }
  async function loadTasks(){
    allTasks = await fetchTasks();
    renderHeader();
    renderBody();
  }

  /* ------------------------------------------------------------------
   * Filters
   * ------------------------------------------------------------------ */
  async function populateFilters(){
    const pj = await (await fetch("/api/projects")).json();
    $("#projectFilter").innerHTML = '<option value="">All projects</option>' +
            pj.map(p=>`<option value="${p.project}">${p.project}</option>`).join("");
    const sp = await (await fetch("/api/sprints")).json();
    $("#sprintFilter").innerHTML = '<option value="">All sprints</option>' +
            sp.map(s=>`<option value="${s.sprint}">${s.sprint}</option>`).join("");
  }

  /* ------------------------------------------------------------------
   * Column picker logic
   * ------------------------------------------------------------------ */
  function openColModal(){
    const cnt = $("#colList");
    cnt.innerHTML="";
    columnsOrder.forEach((c,i)=>{
      const div = document.createElement("div");
      div.className="col-item";
      div.innerHTML = `<button class="col-move" data-idx="${i}" data-dir="up">‚¨ÜÔ∏è</button>` +
              `<button class="col-move" data-idx="${i}" data-dir="down">‚¨áÔ∏è</button>` +
              `<label><input type="checkbox" value="${c.key}" ${visibleCols.has(c.key)?"checked":""}/> ${c.label||c.key}</label>`;
      cnt.appendChild(div);
    });
    showModal($("#colModal"));
  }
  $("#gearBtn").addEventListener("click", openColModal);
  $("#colList").addEventListener("click", e=>{
    if(!e.target.classList.contains("col-move")) return;
    const i = +e.target.dataset.idx, d=e.target.dataset.dir;
    const ni = d==="up"?i-1:i+1;
    if(ni<0||ni>=columnsOrder.length) return;
    [columnsOrder[i],columnsOrder[ni]]=[columnsOrder[ni],columnsOrder[i]];
    openColModal();
  });
  $("#colSaveBtn").addEventListener("click", async ()=>{
    visibleCols.clear();
    $$("#colList input[type=checkbox]").forEach(cb=>{
      if(cb.checked) visibleCols.add(cb.value);
    });
    await saveSettings();
    hideModal($("#colModal"));
    await loadTasks();
  });
  $("#colCancelBtn").addEventListener("click",()=>hideModal($("#colModal")));

  /* ------------------------------------------------------------------
   * Row interactions
   * ------------------------------------------------------------------ */
  $("#tasks").addEventListener("click", async e=>{
    const btn = e.target.closest("button");
    if(btn){
      if(btn.classList.contains("eye")){
        const id=+btn.dataset.id;
        const hideNow=btn.textContent==="üëÅÔ∏è";
        await fetch("/api/tasks/hidden",{
          method:"POST",
          headers:{"Content-Type":"application/json"},
          body:JSON.stringify({id,hidden:hideNow})
        });
        return loadTasks();
      }
      if(btn.classList.contains("arrow")){
        const id=+btn.dataset.id, dir=btn.dataset.dir;
        await fetch("/api/tasks/reorder",{
          method:"POST",
          headers:{"Content-Type":"application/json"},
          body:JSON.stringify({id,direction:dir})
        });
        return loadTasks();
      }
    }
    const cell = e.target;
    const row = cell.closest("tr");
    if(!row) return;
    const taskId=+row.dataset.taskId;

    function inlineEdit(newEl, saveCb){
      cell.textContent="";
      cell.appendChild(newEl);
      newEl.focus();
      newEl.addEventListener("change", async ()=>{
        await saveCb(newEl.value);
        await loadTasks();
      });
      newEl.addEventListener("blur", ()=>loadTasks());
    }

    if(cell.classList.contains("priority-cell")){
      const sel = document.createElement("select");
      ["Low","Medium","High"].forEach(v=>{
        const o=document.createElement("option");
        o.value=v; o.textContent=v;
        if(v===cell.textContent) o.selected=true;
        sel.appendChild(o);
      });
      return inlineEdit(sel,v=>fetch("/api/tasks/priority",{
        method:"POST",
        headers:{"Content-Type":"application/json"},
        body:JSON.stringify({id:taskId,priority:v})
      }));
    }
    if(cell.classList.contains("status-cell")){
      const sel=document.createElement("select");
      ["Not Started","In Progress","Done"].forEach(v=>{
        const o=document.createElement("option");
        o.value=v; o.textContent=v;
        if(v===cell.textContent) o.selected=true;
        sel.appendChild(o);
      });
      return inlineEdit(sel,v=>fetch("/api/tasks/status",{
        method:"POST",
        headers:{"Content-Type":"application/json"},
        body:JSON.stringify({id:taskId,status:v})
      }));
    }
    if(cell.classList.contains("project-cell")){
      const inp=document.createElement("input");
      inp.type="text";
      inp.value=cell.textContent;
      return inlineEdit(inp,v=>fetch("/api/tasks/project",{
        method:"POST",
        headers:{"Content-Type":"application/json"},
        body:JSON.stringify({id:taskId,project:v})
      }));
    }
    if(cell.classList.contains("sprint-cell")){
      const inp=document.createElement("input");
      inp.type="text";
      inp.value=cell.textContent;
      return inlineEdit(inp,v=>fetch("/api/tasks/sprint",{
        method:"POST",
        headers:{"Content-Type":"application/json"},
        body:JSON.stringify({id:taskId,sprint:v})
      }));
    }
    if(cell.classList.contains("dependencies-cell")){
      const inp=document.createElement("input");
      inp.type="text";
      inp.value=cell.textContent;
      return inlineEdit(inp,v=>fetch("/api/tasks/dependencies",{
        method:"POST",
        headers:{"Content-Type":"application/json"},
        body:JSON.stringify({id:taskId,dependencies:v})
      }));
    }
    if(cell.classList.contains("blocking-cell")){
      const inp=document.createElement("input");
      inp.type="text";
      inp.value=cell.textContent;
      return inlineEdit(inp,v=>fetch("/api/tasks/blocking",{
        method:"POST",
        headers:{"Content-Type":"application/json"},
        body:JSON.stringify({id:taskId,blocking:v})
      }));
    }
    if(cell.classList.contains("title-cell")){
      const inp=document.createElement("input");
      inp.type="text";
      inp.value=cell.textContent;
      return inlineEdit(inp,v=>fetch("/api/tasks/rename",{
        method:"POST",
        headers:{"Content-Type":"application/json"},
        body:JSON.stringify({id:taskId,newTitle:v})
      }));
    }
  });

  $("#showHidden").addEventListener("change", loadTasks);
  $("#projectFilter").addEventListener("change", renderBody);
  $("#sprintFilter").addEventListener("change", renderBody);

  /* ------------------------------------------------------------------
   * Modal hooking for instructions, repo, defaults, new task
   * ------------------------------------------------------------------ */
  $("#instrBtn").addEventListener("click", async ()=>{
    const r=await fetch("/api/settings/agent_instructions");
    if(r.ok){
      const {value}=await r.json();
      $("#instrText").value=value||"";
    }
    showModal($("#instrModal"));
  });
  $("#instrSaveBtn").addEventListener("click", async ()=>{
    await fetch("/api/settings",{
      method:"POST",
      headers:{"Content-Type":"application/json"},
      body:JSON.stringify({key:"agent_instructions",value:$("#instrText").value})
    });
    hideModal($("#instrModal"));
  });
  $("#instrCancelBtn").addEventListener("click",()=>hideModal($("#instrModal")));

  $("#repoBtn").addEventListener("click", async ()=>{
    const r=await fetch("/api/settings/github_repo");
    if(r.ok){
      const {value}=await r.json();
      $("#repoInput").value=value||"";
    }
    showModal($("#repoModal"));
  });
  $("#repoSaveBtn").addEventListener("click", async ()=>{
    await fetch("/api/settings",{
      method:"POST",
      headers:{"Content-Type":"application/json"},
      body:JSON.stringify({key:"github_repo",value:$("#repoInput").value})
    });
    hideModal($("#repoModal"));
  });
  $("#repoCancelBtn").addEventListener("click",()=>hideModal($("#repoModal")));

  $("#defaultsBtn").addEventListener("click", async ()=>{
    let r=await fetch("/api/settings/default_project");
    if(r.ok){
      const{value}=await r.json();
      $("#defProjectInput").value=value||"";
    }
    r=await fetch("/api/settings/default_sprint");
    if(r.ok){
      const{value}=await r.json();
      $("#defSprintInput").value=value||"";
    }
    showModal($("#defaultsModal"));
  });
  $("#defSaveBtn").addEventListener("click", async ()=>{
    await fetch("/api/settings",{
      method:"POST",
      headers:{"Content-Type":"application/json"},
      body:JSON.stringify({key:"default_project",value:$("#defProjectInput").value})
    });
    await fetch("/api/settings",{
      method:"POST",
      headers:{"Content-Type":"application/json"},
      body:JSON.stringify({key:"default_sprint",value:$("#defSprintInput").value})
    });
    hideModal($("#defaultsModal"));
  });
  $("#defCancelBtn").addEventListener("click",()=>hideModal($("#defaultsModal")));

  $("#addTaskBtn").addEventListener("click",()=>{
    $("#newTaskTitle").value="";
    $("#newTaskBody").value="";
    showModal($("#newTaskModal"));
  });
  $("#createTaskBtn").addEventListener("click", async ()=>{
    const title=$("#newTaskTitle").value.trim(),
          body=$("#newTaskBody").value.trim();
    if(!title){
      alert("Please enter a title for the new task.");
      return;
    }
    const res=await fetch("/api/tasks/new",{
      method:"POST",
      headers:{"Content-Type":"application/json"},
      body:JSON.stringify({title,body})
    });
    if(!res.ok){
      alert("Error creating task. Check console/logs.");
      return;
    }
    hideModal($("#newTaskModal"));
    await loadTasks();
  });
  $("#cancelTaskBtn").addEventListener("click",()=>hideModal($("#newTaskModal")));

  /* ------------------------------------------------------------------
   * Chat tab logic
   * ------------------------------------------------------------------ */
  async function loadTabs(){
    const res = await fetch("/api/chat/tabs");
    chatTabs = await res.json();
  }
  async function addNewTab(){
    const name = prompt("Enter tab name:", "New Tab");
    if(!name) return;
    const r = await fetch("/api/chat/tabs/new", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ name })
    });
    if(r.ok){
      await loadTabs();
      renderTabs();
    }
  }
  async function renameTab(tabId){
    const t = chatTabs.find(t => t.id===tabId);
    const newName = prompt("Enter new tab name:", t ? t.name : "Untitled");
    if(!newName) return;
    const r = await fetch("/api/chat/tabs/rename", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ tabId, newName })
    });
    if(r.ok){
      await loadTabs();
      renderTabs();
    }
  }
  async function deleteTab(tabId){
    if(!confirm("Are you sure you want to delete this tab (and all its messages)?")) return;
    const r = await fetch(`/api/chat/tabs/${tabId}`, { method: "DELETE" });
    if(r.ok){
      await loadTabs();
      if(chatTabs.length>0){
        currentTabId = chatTabs[0].id;
      } else {
        currentTabId=1; 
      }
      renderTabs();
      await loadChatHistory(currentTabId);
    }
  }
  function selectTab(tabId){
    currentTabId = tabId;
    loadChatHistory(tabId);
    renderTabs();
  }
  function renderTabs(){
    const tc = $("#tabsContainer");
    tc.innerHTML="";
    chatTabs.forEach(tab => {
      const tabBtn = document.createElement("div");
      tabBtn.style.display="flex";
      tabBtn.style.alignItems="center";
      tabBtn.style.border="1px solid #ccc";
      tabBtn.style.padding="4px 6px";
      tabBtn.style.cursor="pointer";
      tabBtn.style.backgroundColor = (tab.id===currentTabId) ? "#eee" : "#f9f9f9";
      tabBtn.textContent = tab.name;
      tabBtn.addEventListener("click", ()=>selectTab(tab.id));

      // Right-click context to rename or delete
      tabBtn.addEventListener("contextmenu", e=>{
        e.preventDefault();
        const choice = prompt("Type 'rename' or 'delete':", "");
        if(choice==="rename") renameTab(tab.id);
        else if(choice==="delete") deleteTab(tab.id);
      });
      tc.appendChild(tabBtn);
    });
  }
  $("#newTabBtn").addEventListener("click", addNewTab);

  /* ------------------------------------------------------------------
   * Chat logic with streaming response
   * ------------------------------------------------------------------ */
  const chatMessagesEl = document.getElementById("chatMessages");
  const chatInputEl = document.getElementById("chatInput");
  const chatSendBtnEl = document.getElementById("chatSendBtn");
  const waitingElem = document.getElementById("waitingCounter");

  function addChatMessage(pairId, userText, userTs, aiText, aiTs, model, systemContext) {
    const seqDiv = document.createElement("div");
    seqDiv.className = "chat-sequence";

    if (systemContext) {
      const sysDiv = document.createElement("div");
      sysDiv.className = "chat-system";
      sysDiv.textContent = systemContext;
      seqDiv.appendChild(sysDiv);
    }

    const userDiv = document.createElement("div");
    userDiv.className = "chat-user";
    userDiv.innerHTML = `You (pair #${pairId}, ${formatTimestamp(userTs)}): ${userText} <a href="/pair/${pairId}" target="_blank">[details]</a>`;
    seqDiv.appendChild(userDiv);

    const botDiv = document.createElement("div");
    botDiv.className = "chat-bot";
    botDiv.innerHTML = `AI (model: ${model}, ${formatTimestamp(aiTs)}): ${aiText || ""} <a href="/pair/${pairId}" target="_blank">[details]</a>`;
    seqDiv.appendChild(botDiv);

    chatMessagesEl.appendChild(seqDiv);
    chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
  }

  async function loadChatHistory(tabId = 1) {
    chatMessagesEl.innerHTML="";
    try {
      const pairs = await fetch(`/api/chat/history?tabId=${tabId}`).then(r => r.json());
      for (const p of pairs) {
        addChatMessage(
          p.id,
          p.user_text,
          p.timestamp,
          p.ai_text,
          p.ai_timestamp,
          p.model,
          p.system_context
        );
      }
    } catch (err) {
      console.error("Error loading chat history:", err);
    }
  }

  chatInputEl.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      e.preventDefault();
      chatSendBtnEl.click();
    }
  });

  chatSendBtnEl.addEventListener("click", async () => {
    const userMessage = chatInputEl.value.trim();
    if(!userMessage) return;

    // Locally computed user timestamp (approximate unless reloaded)
    const userTime = new Date().toISOString();

    // Immediately reflect user input
    const seqDiv = document.createElement("div");
    seqDiv.className = "chat-sequence";

    // Show system context bubble inline for new message
    const sysContext = `System Context:\nModel: ${modelName}\nTimestamp: ${userTime}`;
    const sysDiv = document.createElement("div");
    sysDiv.className = "chat-system";
    sysDiv.textContent = sysContext;
    seqDiv.appendChild(sysDiv);

    const userDiv = document.createElement("div");
    userDiv.className = "chat-user";
    userDiv.innerHTML = `You (pending ID, ${formatTimestamp(userTime)}): ${userMessage}`;
    seqDiv.appendChild(userDiv);

    const botDiv = document.createElement("div");
    botDiv.className = "chat-bot";
    botDiv.textContent = `AI (model: ${modelName}, ...): `;

    seqDiv.appendChild(botDiv);
    chatMessagesEl.appendChild(seqDiv);
    chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
    chatInputEl.value = "";

    let waitTime=0;
    waitingElem.textContent = "Waiting: 0.0s";
    const waitInterval = setInterval(()=>{
      waitTime+=0.1;
      waitingElem.textContent = `Waiting: ${waitTime.toFixed(1)}s`;
    }, 100);

    try {
      const resp = await fetch("/api/chat",{
        method:"POST",
        headers:{"Content-Type":"application/json"},
        body:JSON.stringify({message:userMessage, tabId: currentTabId})
      });
      clearInterval(waitInterval);
      waitingElem.textContent = "";

      if(!resp.ok){
        botDiv.textContent = `AI (model: ${modelName}): [Error contacting AI]`;
      } else {
        const reader = resp.body.getReader();
        let partialText = "";
        while(true){
          const { value, done } = await reader.read();
          if(done) break;
          partialText += new TextDecoder().decode(value);
          botDiv.textContent = `AI (model: ${modelName}, ...): ` + partialText;
          chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
        }
      }
    } catch(e) {
      clearInterval(waitInterval);
      waitingElem.textContent = "";
      botDiv.textContent = `AI (model: ${modelName}): [Error occurred]`;
    }
    chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
  });

  /* ------------------------------------------------------------------
   * Init sequence
   * ------------------------------------------------------------------ */
  (async function init(){
    await loadSettings();
    await populateFilters();
    await loadTasks();
    // Fetch the model name for the HUD
    try {
      const r = await fetch("/api/model");
      if(r.ok){
        const data = await r.json();
        modelName = data.model || "unknown";
      }
    } catch(e){
      modelName = "unknown";
    }
    // Display the model in the HUD
    $("#modelHud").textContent = "Model: " + modelName;

    // Load chat tabs
    await loadTabs();
    if(chatTabs.length>0){
      currentTabId = chatTabs[0].id;
    } else {
      // Ensure at least one default tab
      await fetch("/api/chat/tabs/new", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ name: "Main" })
      });
      await loadTabs();
      currentTabId = chatTabs[0].id;
    }
    renderTabs();
    await loadChatHistory(currentTabId);
  })();
</script>
</body>
</html>
