<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<!--  <title>Printify Pipeline Queue</title>-->
  <title>Design Production Queue</title>
  <link rel="stylesheet" href="./styles.css">
  <style>
    .img-dropdown {
      position: relative;
      min-width: 400px;
      width: 400px;
      cursor: pointer;
    }
    .img-dropdown .selected {
      border: 1px solid #444;
      padding: 4px;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      background-color: #222;
    }
    .img-dropdown .selected img {
      max-height: 240px;
    }
    .img-dropdown .options {
      position: absolute;
      left: 0;
      right: 0;
      top: 100%;
      background-color: #222;
      border: 1px solid #444;
      max-height: 600px;
      overflow-y: auto;
      width: 400px;
      z-index: 1000;
      display: none;
    }
    .img-dropdown .option {
      padding: 4px;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .img-dropdown .option img {
      max-height: 240px;
    }
    .img-dropdown .option:hover {
      background-color: #333;
    }
    .img-dropdown .loading-more {
      text-align: center;
      padding: 4px;
    }
    .upscaled-label {
      color: cyan;
      margin-left: 0.25rem;
    }
    .status-success {
      color: #0f0;
    }
    .status-failed {
      color: #f33;
    }
    .db-group td {
      background-color: #333;
      color: cyan;
      font-weight: bold;
    }
    .group-header td {
      background-color: #222;
      font-weight: bold;
    }
    .db-group { cursor: pointer; }
    .db-group .toggle { margin-right: 0.25rem; }
    .group-header .toggle { margin-right: 0.25rem; cursor: pointer; }
  </style>
</head>
<body style="padding:1rem;">
<!--  <h2>Printify Pipeline Queue</h2>-->
<h2>Design Production Queue</h2>
  <p>
    <a href="/">‚Üê Back</a>
    |
    <a href="jobs_log.html" target="_blank">Jobs Log</a>
  </p>
  <div id="addJob" style="margin-bottom:1rem;display:flex;align-items:center;gap:0.5rem;">
    <label>Type:
      <select id="jobType">
        <option value="upscale">Upscale</option>
        <option value="printify">Printify</option>
        <option value="printifyTitleFix">Printify Title Fix</option>
        <option value="printifyFixMockups">Printify Fix Mockups</option>
        <option value="printifyFinalize">Printify Finalize</option>
        <option value="all">All</option>
      </select>
    </label>
    <label>Image:
      <div id="imageSelect" class="img-dropdown">
        <div class="selected">-- choose --</div>
        <div class="options">
          <div class="loading-more"><span class="loading-spinner"></span></div>
        </div>
      </div>
    </label>
    <img id="imagePreview" style="display:none;max-height:80px;border:1px solid #444;" />
    <div id="variantChoice" style="display:none;flex-direction:column;margin-left:0.5rem;">
      <label style="display:block;margin-bottom:0.25rem;">
        <input type="radio" id="choiceQueueNormal" name="queueVariant" value="normal" />
        Use 4096 image:
        <span id="queueNormalPath"></span>
      </label>
      <label style="display:block;">
        <input type="radio" id="choiceQueueNobg" name="queueVariant" value="nobg" />
        Use 4096 no background:
        <span id="queueNobgPath"></span>
      </label>
    </div>
    <label style="margin-left:0.5rem;">
      <input type="checkbox" id="hideWhenAdd" /> Hide when adding to queue
    </label>
    <button id="enqueueBtn">Add to Queue</button>
    <button id="hideSelectedBtn" style="margin-left:0.5rem;">Hide</button>
    <button id="stopAllBtn" style="margin-left:0.5rem;">Stop All</button>
    <span id="queueState" style="margin-left:0.5rem;">Running</span>
    <button id="pauseBtn" style="margin-left:0.5rem;">Pause</button>
  </div>
  <table id="queueTable">
    <thead>
      <tr>
        <th>ID</th>
        <th>DB ID</th>
        <th>Type</th>
        <th>Location</th>
        <th>Variant</th>
        <th>Start</th>
        <th>Finish</th>
        <th>Status</th>
        <th>Job ID</th>
        <th>Result Path</th>
        <th>Product URL</th>
        <th>Actions</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>
  <script src="./session.js"></script>
  <script>
    console.debug('[Queue UI] script loaded');
    if (typeof window.CSS === 'undefined') window.CSS = {};
    if (typeof window.CSS.escape !== 'function') {
      window.CSS.escape = function(str) {
        return String(str).replace(/[^\w-]/g, function(ch) {
          return '\\' + ch;
        });
      };
    }
    const collapsedGroups = new Set(JSON.parse(localStorage.getItem('collapsedQueueGroups') || '[]'));
    const saveCollapsed = () => {
      localStorage.setItem('collapsedQueueGroups', JSON.stringify([...collapsedGroups]));
    };
    const titleCache = {};
    async function getTitle(file){
      if(titleCache.hasOwnProperty(file)) return titleCache[file];
      try{
        const r = await fetch('api/upload/title?name=' + encodeURIComponent(file));
        const d = await r.json();
        titleCache[file] = d.title || '';
      }catch(e){
        console.error('Failed to fetch title', e);
        titleCache[file] = '';
      }
      return titleCache[file];
    }
    async function loadQueue(){
      console.debug('[Queue UI] loading queue...');
      try{
        const res = await fetch('api/pipelineQueue');
        const queue = await res.json();
        console.debug('[Queue UI] queue data =>', queue);
        const tbody = document.querySelector('#queueTable tbody');
        tbody.innerHTML = '';

        const parseTime = j => {
          if(j.startTime) return j.startTime;
          const n = parseInt(j.id, 36);
          return Number.isNaN(n) ? 0 : n;
        };

        const groups = new Map();
        for(const job of queue){
          const key = job.dbId || '';
          if(!groups.has(key)) groups.set(key, []);
          groups.get(key).push(job);
        }

        for(const list of groups.values()){
          list.sort((a,b) => parseTime(a) - parseTime(b));
        }

        const groupEntries = Array.from(groups.entries()).sort((a,b) => {
          return parseTime(a[1][0]) - parseTime(b[1][0]);
        });

        for(const [dbId, jobs] of groupEntries){
          if(dbId){
            const firstJob = jobs[0];
            const groupTr = document.createElement('tr');
            groupTr.className = 'db-group';
            groupTr.dataset.dbid = dbId;
            const collapsed = collapsedGroups.has(dbId);
            const title = await getTitle(firstJob.file);
            const titlePart = title ? ` - ${title}` : '';
            groupTr.innerHTML = `<td colspan="12"><span class="toggle">${collapsed ? '[+]' : '[-]'}</span> DB ID: ${dbId}${titlePart}<img src="uploads/${encodeURIComponent(firstJob.file)}" style="max-height:40px;margin-left:0.5rem;vertical-align:middle;" /> <button class="hideImageBtn" data-file="${encodeURIComponent(firstJob.file)}" style="margin-left:0.5rem;">Hide Image</button> <button class="removeDbBtn" data-dbid="${dbId}" style="margin-left:0.5rem;">Remove All</button></td>`;
            tbody.appendChild(groupTr);
            const headerTr = document.createElement('tr');
            headerTr.className = 'group-header';
            headerTr.dataset.dbid = dbId;

            const startTimes = jobs.map(j => j.startTime).filter(t => t);
            const earliestStart = startTimes.length ? Math.min(...startTimes) : null;
            const finalizeJob = jobs.find(j => j.type === 'printifyFinalize');
            const finishTime = finalizeJob && finalizeJob.finishTime ? finalizeJob.finishTime : null;
            const productUrl = (finalizeJob && finalizeJob.productUrl) || (jobs.find(j => j.productUrl) || {}).productUrl || '';
            let groupStatus = 'queued';
            if(jobs.some(j => j.status === 'failed' || j.status === 'error')){
              groupStatus = 'failed';
            }else if(finalizeJob && finalizeJob.status === 'finished'){
              groupStatus = 'finished';
            }else if(jobs.some(j => j.status === 'running')){
              groupStatus = 'running';
            }
            const statusHtml = (() => {
              if(groupStatus === 'running') return 'Running <span class="loading-spinner"></span>';
              if(groupStatus === 'finished') return '<span class="status-success">Finished</span>';
              if(groupStatus === 'failed') return '<span class="status-failed">Failed</span>';
              return groupStatus;
            })();
            const startStr = earliestStart ? new Date(earliestStart).toLocaleString() : '';
            const finishStr = finishTime ? new Date(finishTime).toLocaleString() : '';

            const productLink = productUrl ? `<a href="${productUrl}" target="_blank">${productUrl}</a>` : '';

            headerTr.innerHTML = `
              <td></td>
              <td><span class="toggle">${collapsed ? '[+]' : '[-]'}</span> DB ID: ${dbId}<img src="uploads/${encodeURIComponent(firstJob.file)}" style="max-height:40px;margin-left:0.5rem;vertical-align:middle;" /> <button class="removeDbBtn" data-dbid="${dbId}" style="margin-left:0.5rem;">Remove</button></td>
              <td></td>
              <td></td>
              <td></td>
              <td>${startStr}</td>
              <td>${finishStr}</td>
              <td>${statusHtml}</td>
              <td></td>
              <td></td>
              <td>${productLink}</td>
              <td></td>
            `;

            // Always display the header row even when group is collapsed
            // Only job rows should be hidden when collapsed
            tbody.appendChild(headerTr);
            headerTr.querySelector('.removeDbBtn')?.addEventListener('click', async ev => {
              ev.stopPropagation();
              await removeJobsByDbId(dbId);
            });
            groupTr.querySelector('.removeDbBtn').addEventListener('click', async ev => {
              ev.stopPropagation();
              await removeJobsByDbId(dbId);
            });
            groupTr.querySelector('.hideImageBtn').addEventListener('click', async ev => {
              ev.stopPropagation();
              const file = decodeURIComponent(ev.target.dataset.file || '');
              if(!file) return;
              try{
                await fetch('api/upload/hidden', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ name: file, hidden: true })
                });
                const opt = optionsDiv.querySelector(`.option[data-value="${CSS.escape(file)}"]`);
                opt?.remove();
                if(dropdown.dataset.value === file || dropdown.value === file){
                  selectedDiv.textContent = '-- choose --';
                  dropdown.dataset.value = '';
                  dropdown.value = '';
                  dropdown.dataset.id = '';
                  updatePreview('');
                  updateVariantUI('');
                }
              }catch(err){
                console.error('Failed to hide image', err);
              }
            });
            const toggleGroup = () => {
              const wasCollapsed = collapsedGroups.has(dbId);
              if(wasCollapsed){
                collapsedGroups.delete(dbId);
              }else{
                collapsedGroups.add(dbId);
              }
              const nowCollapsed = collapsedGroups.has(dbId);
              [groupTr, headerTr].forEach(row => {
                const t = row.querySelector('.toggle');
                if(t) t.textContent = nowCollapsed ? '[+]' : '[-]';
              });
              saveCollapsed();
              tbody.querySelectorAll(`tr[data-dbid="${dbId}"]:not(.group-header)`).forEach(r => {
                if(r !== groupTr) r.style.display = nowCollapsed ? 'none' : '';
              });
            };
            groupTr.addEventListener('click', e => {
              if(e.target.classList.contains('removeDbBtn') || e.target.classList.contains('hideImageBtn')) return;
              toggleGroup();
            });
            headerTr.addEventListener('click', e => {
              if(e.target.classList.contains('removeDbBtn')) return;
              toggleGroup();
            });
          }

          for(const job of jobs){
            const tr = document.createElement('tr');
          const jobLink = job.jobId ? `<a href="jobs.html?jobId=${job.jobId}" target="_blank">${job.jobId}</a>` : '';
          const dbLink = job.dbId
            ? `<a href="/Image.html?file=${encodeURIComponent(job.file)}" target="_blank">${job.dbId}</a>`
            : '';
          const statusHtml = (() => {
            if(job.status === 'running') return 'Running <span class="loading-spinner"></span>';
            if(job.status === 'finished') return '<span class="status-success">Finished</span>';
            if(job.status === 'failed' || job.status === 'error') return '<span class="status-failed">Failed</span>';
            return job.status;
          })();
          const startStr = job.startTime ? new Date(job.startTime).toLocaleString() : '';
          const finishStr = job.finishTime ? new Date(job.finishTime).toLocaleString() : '';
          tr.innerHTML = `
            <td>${job.id}</td>
            <td>${dbLink}</td>
            <td>${job.type}</td>
            <td>${job.location}</td>
            <td>${job.variant || ''}</td>
            <td>${startStr}</td>
            <td>${finishStr}</td>
            <td>${statusHtml}</td>
            <td>${jobLink}</td>
            <td>${job.resultPath || ''}</td>
            <td>${job.productUrl ? `<a href="${job.productUrl}" target="_blank">${job.productUrl}</a>` : ''}</td>
            <td><button data-id="${job.id}" class="removeBtn">Remove</button></td>
          `;
            tr.dataset.dbid = job.dbId || '';
            if(job.dbId && collapsedGroups.has(job.dbId)) tr.style.display = 'none';
            tbody.appendChild(tr);
            tr.querySelector('.removeBtn').addEventListener('click', async () => {
              await removeJob(job.id);
            });
          }
        }
      }catch(e){
        console.error('Failed to load queue', e);
      }
    }
    const dropdown = document.getElementById('imageSelect');
    const selectedDiv = dropdown.querySelector('.selected');
    const optionsDiv = dropdown.querySelector('.options');
    const loadingDiv = optionsDiv.querySelector('.loading-more');

    let imgOffset = 0;
    let imgHasMore = true;
    let imgLoading = false;

    async function loadImages(reset=false){
      console.debug('[Queue UI] loadImages reset=' + reset);
      if(imgLoading) return;
      if(reset){
        imgOffset = 0;
        imgHasMore = true;
        optionsDiv.querySelectorAll('.option').forEach(o => o.remove());
        if(!dropdown.dataset.value){
          selectedDiv.textContent = '-- choose --';
        }
      }
      if(!imgHasMore) return;
      imgLoading = true;
      loadingDiv.style.display = 'block';
      try{
        const res = await fetch('api/upload/list?sessionId=' + encodeURIComponent(sessionId) + `&limit=20&offset=${imgOffset}&showHidden=0`);
        const files = await res.json();
        console.debug('[Queue UI] loaded images =>', files);
        files.forEach(f => {
          const item = document.createElement('div');
          item.className = 'option';
          item.dataset.value = f.name;
          item.dataset.id = f.id ?? '';
          const idx = (f.id !== null && f.id !== undefined) ? f.id : '';
          const upscaled = f.status && /upscaled/i.test(f.status);
          const label = upscaled ? '<span class="upscaled-label">[upscaled]</span>' : '';
          item.innerHTML = `<img src="uploads/${encodeURIComponent(f.name)}" /> <span>${idx}${label}</span>`;
          item.addEventListener('click', ev => {
            selectedDiv.innerHTML = `<img src="uploads/${encodeURIComponent(f.name)}" /> <span>${idx}${label}</span>`;
            dropdown.dataset.value = f.name;
            dropdown.dataset.id = f.id ?? '';
            optionsDiv.style.display = 'none';
            updatePreview(f.name);
            const type = document.getElementById('jobType').value;
            if(type === 'printify' || type === 'printifyPrice' || type === 'printifyTitleFix' || type === 'printifyFixMockups' || type === 'printifyFinalize' || type === 'all'){
              updateVariantUI(f.name);
            }
          });
          optionsDiv.appendChild(item);
        });
        imgOffset += files.length;
        if(files.length < 20) imgHasMore = false;
      }catch(e){
        console.error('Failed to load images', e);
      }
      imgLoading = false;
      loadingDiv.style.display = 'none';
    }

    const toggleOptions = () => {
      optionsDiv.style.display = optionsDiv.style.display === 'block' ? 'none' : 'block';
      if(optionsDiv.style.display === 'block' && optionsDiv.querySelectorAll('.option').length === 0){
        loadImages(true);
      }
    };

    selectedDiv.addEventListener('click', toggleOptions);
    selectedDiv.addEventListener('touchstart', e => {
      e.preventDefault();
      toggleOptions();
    });

    document.addEventListener('click', e => {
      if(!dropdown.contains(e.target)) optionsDiv.style.display = 'none';
    });
    document.addEventListener('touchstart', e => {
      if(!dropdown.contains(e.target)) optionsDiv.style.display = 'none';
    });

    optionsDiv.addEventListener('scroll', () => {
      if(optionsDiv.scrollTop + optionsDiv.clientHeight >= optionsDiv.scrollHeight - 5){
        loadImages();
      }
    });

    function updatePreview(val){
      const img = document.getElementById('imagePreview');
      if(val){
        img.src = 'uploads/' + encodeURIComponent(val);
        img.style.display = '';
      }else{
        img.style.display = 'none';
      }
    }

    document.getElementById('jobType').addEventListener('change', () => {
      const type = document.getElementById('jobType').value;
      if(type === 'printify' || type === 'printifyPrice' || type === 'printifyTitleFix' || type === 'printifyFixMockups' || type === 'printifyFinalize' || type === 'all'){
        const sel = document.getElementById('imageSelect');
        updateVariantUI(sel.dataset.value || sel.value);
      } else {
        document.getElementById('variantChoice').style.display = 'none';
      }
    });

async function updateVariantUI(file){
  console.debug('[Queue UI] updateVariantUI for', file);
  const choiceDiv = document.getElementById('variantChoice');
  const normalRadio = document.getElementById('choiceQueueNormal');
  const nobgRadio = document.getElementById('choiceQueueNobg');
  const normalPath = document.getElementById('queueNormalPath');
  const nobgPath = document.getElementById('queueNobgPath');
  const type = document.getElementById('jobType').value;

  if(!file){
    choiceDiv.style.display = 'none';
    normalRadio.disabled = nobgRadio.disabled = true;
    normalPath.textContent = nobgPath.textContent = '';
    return;
  }
  try{
    const res = await fetch(`api/upscale/result?file=${encodeURIComponent(file)}`);
    const data = await res.json();
    const upPath = data.url || null;
    const nbPath = data.nobgUrl || (data.url && /(?:[_-](?:no)?[-_]?bg)/i.test(data.url) ? data.url : null);
    if(upPath){
      normalPath.textContent = upPath;
      normalRadio.disabled = false;
    }else{
      normalPath.textContent = type === 'all' ? '(will be generated)' : '(not found)';
      normalRadio.disabled = type !== 'all';
    }
    if(nbPath){
      nobgPath.textContent = nbPath;
      nobgRadio.disabled = false;
    }else{
      nobgPath.textContent = type === 'all' ? '(will be generated)' : '(not found)';
      nobgRadio.disabled = type !== 'all';
    }
    if(upPath || nbPath || type === 'all'){
      choiceDiv.style.display = '';
      if(nbPath){
        nobgRadio.checked = true;
      } else if(type === 'all'){
        nobgRadio.checked = true;
        normalRadio.checked = false;
      } else if(upPath){
        normalRadio.checked = true;
      } else {
        normalRadio.checked = nobgRadio.checked = false;
      }
    }else{
      choiceDiv.style.display = 'none';
    }
  }catch(e){
    console.error('Failed to check variant paths', e);
    choiceDiv.style.display = 'none';
  }
}

    document.getElementById('enqueueBtn').addEventListener('click', async () => {
      const selectEl = document.getElementById('imageSelect');
      const file = selectEl.dataset.value || selectEl.value;
      let dbId = selectEl.dataset.id;
      if(!dbId && selectEl.selectedOptions && selectEl.selectedOptions[0]){
        dbId = selectEl.selectedOptions[0].dataset.id || '';
      }
      const type = document.getElementById('jobType').value;
      const variantChoice = document.querySelector('input[name="queueVariant"]:checked');
      const variant = variantChoice ? variantChoice.value : null;
      const hideFlag = document.getElementById('hideWhenAdd').checked;
      if(!file) return;
      console.debug('[Queue UI] enqueue clicked file=' + file + ' type=' + type + ' variant=' + variant);
      try{
        if(type === 'all'){
          const steps = ['upscale','printify','printifyTitleFix','printifyFixMockups','printifyFinalize'];
          for(const step of steps){
            await fetch('api/pipelineQueue', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ file, type: step, dbId, variant })
            });
          }
        } else {
          await fetch('api/pipelineQueue', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ file, type, dbId, variant })
          });
          console.debug('[Queue UI] job enqueued');
        }
        if(hideFlag){
          try{
            await fetch('api/upload/hidden', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ name: file, hidden: true })
            });
            const opt = optionsDiv.querySelector(`.option[data-value="${CSS.escape(file)}"]`);
            opt?.remove();
            if(dropdown.dataset.value === file || dropdown.value === file){
              selectedDiv.textContent = '-- choose --';
              dropdown.dataset.value = '';
              dropdown.value = '';
              dropdown.dataset.id = '';
              updatePreview('');
              updateVariantUI('');
            }
          }catch(err){
            console.error('Failed to hide image', err);
          }
        }
        await loadQueue();
      }catch(e){
        console.error('Failed to enqueue job', e);
      }
    });

    document.getElementById('hideSelectedBtn').addEventListener('click', async () => {
      const selectEl = document.getElementById('imageSelect');
      const file = selectEl.dataset.value || selectEl.value;
      if(!file) return;
      try{
        await fetch('api/upload/hidden', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name: file, hidden: true })
        });
        const opt = optionsDiv.querySelector(`.option[data-value="${CSS.escape(file)}"]`);
        opt?.remove();
        selectedDiv.textContent = '-- choose --';
        dropdown.dataset.value = '';
        dropdown.value = '';
        dropdown.dataset.id = '';
        updatePreview('');
        updateVariantUI('');
      }catch(e){
        console.error('Failed to hide image', e);
      }
    });

    async function removeJob(id){
      console.debug('[Queue UI] removeJob', id);
      try{
        await fetch(`api/pipelineQueue/${id}`, { method: 'DELETE' });
        await loadQueue();
      }catch(e){
        console.error('Failed to remove job', e);
      }
    }

    async function removeJobsByDbId(dbId){
      console.debug('[Queue UI] removeJobsByDbId', dbId);
      try{
        await fetch(`api/pipelineQueue/db/${encodeURIComponent(dbId)}`, { method: 'DELETE' });
        collapsedGroups.delete(String(dbId));
        saveCollapsed();
        await loadQueue();
      }catch(e){
        console.error('Failed to remove jobs', e);
      }
    }

    async function loadQueueState(){
      try{
        const res = await fetch('api/pipelineQueue/state');
        const data = await res.json();
        document.getElementById('queueState').textContent = data.paused ? 'Paused' : 'Running';
        document.getElementById('pauseBtn').textContent = data.paused ? 'Resume' : 'Pause';
      }catch(e){
        console.error('Failed to load queue state', e);
      }
    }

    document.getElementById('pauseBtn').addEventListener('click', async () => {
      const btn = document.getElementById('pauseBtn');
      const paused = btn.textContent === 'Resume';
      try{
        await fetch('api/pipelineQueue/' + (paused ? 'resume' : 'pause'), { method: 'POST' });
        await loadQueueState();
      }catch(e){
        console.error('Failed to toggle queue state', e);
      }
    });

    document.getElementById('stopAllBtn').addEventListener('click', async () => {
      if(!confirm('Stop all jobs?')) return;
      try{
        await fetch('api/pipelineQueue/stopAll', { method: 'POST' });
        await loadQueue();
      }catch(e){
        console.error('Failed to stop all jobs', e);
      }
    });

    loadQueue();
    loadImages(true);
    document.getElementById('jobType').dispatchEvent(new Event('change'));
    loadQueueState();
    setInterval(() => { loadQueue(); loadQueueState(); }, 5000);
  </script>
</body>
</html>
