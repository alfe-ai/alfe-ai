<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<!--  <title>Printify Pipeline Queue</title>-->
  <title>Alfe - Design Production Queue</title>
  <link rel="stylesheet" href="./styles.css">
  <link id="favicon" rel="icon" type="image/x-icon" href="/alfe_favicon_64x64.ico">
  <style>
    .img-dropdown {
      position: relative;
      min-width: 400px;
      width: 400px;
      cursor: pointer;
    }
    .img-dropdown .selected {
      border: 1px solid #444;
      padding: 4px;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      background-color: #222;
    }
    .img-dropdown .selected img {
      max-height: 240px;
    }
    .img-dropdown .options {
      position: absolute;
      left: 0;
      right: 0;
      top: 100%;
      background-color: #222;
      border: 1px solid #444;
      max-height: 600px;
      overflow-y: auto;
      width: 400px;
      z-index: 1000;
      display: none;
    }
    .img-dropdown .option {
      padding: 4px;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .img-dropdown .option img {
      max-height: 240px;
    }
    .img-dropdown .option:hover {
      background-color: #333;
    }
    .img-dropdown .loading-more {
      text-align: center;
      padding: 4px;
    }
    .upscaled-label {
      color: cyan;
      margin-left: 0.25rem;
    }
    .status-success {
      color: #0f0;
    }
    .status-failed {
      color: #f33;
    }
    .queue-state-running {
      color: #006400;
    }
    .queue-state-paused {
      color: #ff8c00;
    }
    .db-group td {
      background-color: #333;
      color: cyan;
      font-weight: bold;
    }
    .group-header td {
      background-color: #222;
      font-weight: bold;
    }
    .db-group { cursor: pointer; }
    .db-group .toggle { margin-right: 0.25rem; }
    .group-header .toggle { margin-right: 0.25rem; cursor: pointer; }
    #thumbnailContainer {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    .thumb-entry img {
      display: block;
      width: 100%;
      max-width: 200px;
      aspect-ratio: 1 / 1;
      object-fit: cover;
      border: 1px solid #444;
    }
    .thumb-entry button {
      margin-top: 0.25rem;
      margin-right: 0.25rem;
    }
  </style>
</head>
<body>
  <div class="app">
    <div id="imageSidebar" class="sidebar">
      <div id="thumbnailContainer"></div>
      <div id="sidebarLoading" class="loading-more" style="display:none;"><span class="loading-spinner"></span></div>
      <button id="sidebarLoadMoreBtn" style="display:none;width:100%;margin-top:0.5rem;">Load More</button>
    </div>
    <div class="chat-panel" style="padding:1rem;">
<!--  <h2>Printify Pipeline Queue</h2>-->
<h2>Design Production Queue</h2>
  <p>
    <a href="/">‚Üê Back</a>
    |
    <a href="jobs_log.html" target="_blank">Jobs Log</a>
  </p>
  <div id="addJob" style="margin-bottom:1rem;display:flex;align-items:center;gap:0.5rem;">
    <label>Type:
      <select id="jobType">
        <option value="upscale">Upscale/BackgroundRemove</option>
        <option value="colorIdentify">Color Identify</option>
        <option value="printify">Printify</option>
        <option value="printifyTitleFix">Printify Title Fix</option>
        <option value="printifyFixMockups">Printify Fix Mockups</option>
        <option value="printifyFinalize">Printify Finalize</option>
        <option value="all">All</option>
      </select>
    </label>
    <label>Image:
      <div id="imageSelect" class="img-dropdown">
        <div class="selected">-- choose --</div>
        <div class="options">
          <div class="loading-more"><span class="loading-spinner"></span></div>
        </div>
      </div>
    </label>
    <img id="imagePreview" style="display:none;max-height:80px;border:1px solid #444;" />
    <div id="variantChoice" style="display:none;flex-direction:column;margin-left:0.5rem;">
      <label style="display:block;margin-bottom:0.25rem;">
        <input type="radio" id="choiceQueueNormal" name="queueVariant" value="normal" />
        Use 4096 image:
        <span id="queueNormalPath"></span>
      </label>
      <label style="display:block;">
        <input type="radio" id="choiceQueueNobg" name="queueVariant" value="nobg" />
        Use 4096 no background:
        <span id="queueNobgPath"></span>
      </label>
    </div>
    <label style="margin-left:0.5rem;">
      <input type="checkbox" id="hideWhenAdd" /> Hide when adding to queue
    </label>
    <label style="margin-left:0.5rem;">
      <input type="checkbox" id="queueTopCheckbox" /> Add to top
    </label>
    <button id="enqueueBtn">Add to Queue</button>
    <button id="hideSelectedBtn" style="margin-left:0.5rem;">Hide</button>
    <button id="stopAllBtn" style="margin-left:0.5rem;">Stop All</button>
    <button id="retryFailedBtn" style="margin-left:0.5rem;">Retry Failed</button>
    <button id="removeFinishedBtn" style="margin-left:0.5rem;">Remove All Finished</button>
    <label style="margin-left:0.5rem;">
      <input type="checkbox" id="autoRetryCheckbox" /> Auto Retry Failed
    </label>
    <span id="retryCountdown" style="margin-left:0.25rem;display:none;"></span>
    <span id="queueState" style="margin-left:0.5rem;" class="queue-state-running">Running</span>
    <button id="pauseBtn" style="margin-left:0.5rem;">Pause</button>
  </div>
  <table id="queueTable">
    <thead>
      <tr>
        <th>ID</th>
        <th>DB ID</th>
        <th>Type</th>
        <th>Location</th>
        <th>Variant</th>
        <th>Start</th>
        <th>Finish</th>
        <th>Status</th>
        <th>Job ID</th>
        <th>Result Path</th>
        <th>Product URL</th>
        <th>Actions</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>
  <div style="text-align:center;margin-top:1rem;">
    <button id="loadMoreBtn" style="display:none;">Load More</button>
    <button id="loadAllBtn" style="display:none;margin-left:0.5rem;">Load All</button>
  </div>
  <script src="./session.js"></script>
  <script>
    console.debug('[Queue UI] script loaded');
    if (typeof window.CSS === 'undefined') window.CSS = {};
    if (typeof window.CSS.escape !== 'function') {
      window.CSS.escape = function(str) {
        return String(str).replace(/[^\w-]/g, function(ch) {
          return '\\' + ch;
        });
      };
    }
    const collapsedGroups = new Set(JSON.parse(localStorage.getItem('collapsedQueueGroups') || '[]'));
    const seenDbIds = new Set();
    const saveCollapsed = () => {
      localStorage.setItem('collapsedQueueGroups', JSON.stringify([...collapsedGroups]));
    };
    const queueTopCheckbox = document.getElementById('queueTopCheckbox');
    queueTopCheckbox.checked = localStorage.getItem('queueAddTop') === '1';
    queueTopCheckbox.addEventListener('change', () => {
      localStorage.setItem('queueAddTop', queueTopCheckbox.checked ? '1' : '0');
    });
    const titleCache = {};
    let titlesLoaded = false;
    async function prefetchTitles(){
      if(titlesLoaded) return;
      try{
        const r = await fetch('api/upload/list?sessionId=' + encodeURIComponent(sessionId) + '&showHidden=1&limit=0&offset=0');
        const list = await r.json();
        list.forEach(f => { titleCache[f.name] = f.title || ''; });
        titlesLoaded = true;
      }catch(e){
        console.error('Failed to prefetch titles', e);
      }
    }

    const loadMoreBtn = document.getElementById('loadMoreBtn');
    const loadAllBtn = document.getElementById('loadAllBtn');
    function updateLoadMoreBtn(){
      if(loadMoreBtn){
        loadMoreBtn.style.display = queueHasMore ? 'block' : 'none';
        loadMoreBtn.disabled = queueLoading;
      }
      if(loadAllBtn){
        loadAllBtn.style.display = queueHasMore ? 'block' : 'none';
        loadAllBtn.disabled = queueLoading;
      }
    }

    let queueOffset = 0;
    let queueHasMore = true;
    let queueLoading = false;
    function getTitle(file){
      return titleCache[file] || '';
    }

    function hexToColorName(hex){
      if(!hex) return '';
      hex = hex.trim();
      if(hex.startsWith('#')) hex = hex.slice(1);
      if(hex.length === 3) hex = hex.split('').map(c => c + c).join('');
      const r = parseInt(hex.slice(0,2),16)/255;
      const g = parseInt(hex.slice(2,4),16)/255;
      const b = parseInt(hex.slice(4,6),16)/255;
      const max = Math.max(r,g,b), min = Math.min(r,g,b);
      const l = (max + min) / 2;
      const d = max - min;
      let h = 0, s = 0;
      if(d !== 0){
        s = d / (1 - Math.abs(2*l - 1));
        switch(max){
          case r: h = ((g-b)/d) % 6; break;
          case g: h = (b-r)/d + 2; break;
          case b: h = (r-g)/d + 4; break;
        }
        h *= 60;
        if(h < 0) h += 360;
      }
      if(s < 0.1){
        if(l >= 0.9) return 'white';
        if(l <= 0.1) return 'black';
        return 'gray';
      }
      if(h < 15 || h >= 345) return 'red';
      if(h < 45) return 'orange';
      if(h < 75) return 'yellow';
      if(h < 165) return 'green';
      if(h < 195) return 'cyan';
      if(h < 255) return 'blue';
      if(h < 285) return 'purple';
      if(h < 315) return 'magenta';
      return 'pink';
    }

    function formatColorIdentifyResult(str){
      return str
        .split(/\s*,\s*/)
        .map(c => /^#/i.test(c) ? hexToColorName(c) : c)
        .join(', ');
    }
    async function loadQueue(reset=false){
      console.debug('[Queue UI] loading queue... reset=' + reset);
      if(queueLoading) return;
      if(reset){
        queueOffset = 0;
        queueHasMore = true;
        seenDbIds.clear();
        document.querySelector('#queueTable tbody').innerHTML = '';
        updateLoadMoreBtn();
      }
      if(!queueHasMore) return;
      queueLoading = true;
      updateLoadMoreBtn();
      await prefetchTitles();
      try{
        const res = await fetch(`api/pipelineQueue?limit=20&offset=${queueOffset}`);
        const queue = await res.json();
        console.debug('[Queue UI] queue data =>', queue);
        const tbody = document.querySelector('#queueTable tbody');

        const parseTime = j => {
          if(j.startTime) return j.startTime;
          const n = parseInt(j.id, 36);
          return Number.isNaN(n) ? 0 : n;
        };

        const groups = new Map();
        for(const job of queue){
          const key = job.dbId || '';
          if(!groups.has(key)) groups.set(key, []);
          groups.get(key).push(job);
        }

        const groupEntries = Array.from(groups.entries());

        for(const [dbId, jobs] of groupEntries){
          if(dbId){
            const isNewGroup = !seenDbIds.has(dbId);
            seenDbIds.add(dbId);
            if(isNewGroup && !collapsedGroups.has(dbId)){
              collapsedGroups.add(dbId);
              saveCollapsed();
            }
            const firstJob = jobs[0];
            const groupTr = document.createElement('tr');
            groupTr.className = 'db-group';
            groupTr.dataset.dbid = dbId;
            const collapsed = collapsedGroups.has(dbId);
            const title = getTitle(firstJob.file);
            const titlePart = title ? ` - ${title}` : '';
            groupTr.innerHTML = `<td colspan="12"><span class="toggle">${collapsed ? '[+]' : '[-]'}</span> DB ID: ${dbId}${titlePart}<img src="uploads/${encodeURIComponent(firstJob.file)}" style="max-height:40px;margin-left:0.5rem;vertical-align:middle;" /> <button class="hideImageBtn" data-file="${encodeURIComponent(firstJob.file)}" style="margin-left:0.5rem;">Hide Image</button> <button class="moveTopBtn" style="margin-left:0.5rem;">Move to top</button> <button class="removeDbBtn" data-dbid="${dbId}" style="margin-left:0.5rem;">Remove All</button></td>`;
            tbody.appendChild(groupTr);
            groupTr.draggable = true;
            const headerTr = document.createElement('tr');
            headerTr.className = 'group-header';
            headerTr.dataset.dbid = dbId;
            headerTr.draggable = true;

            const startTimes = jobs.map(j => j.startTime).filter(t => t);
            const earliestStart = startTimes.length ? Math.min(...startTimes) : null;
            const finalizeJobs = jobs.filter(j => j.type === 'printifyFinalize');
            const finalizeJob = finalizeJobs[finalizeJobs.length - 1];
            const finishTime = finalizeJob && finalizeJob.finishTime ? finalizeJob.finishTime : null;
            const productUrl = (finalizeJob && finalizeJob.productUrl) || (jobs.find(j => j.productUrl) || {}).productUrl || '';
            let groupStatus = 'queued';
            if(jobs.some(j => j.status === 'running')){
              groupStatus = 'running';
            }else if(jobs.some(j => j.status === 'failed' || j.status === 'error')){
              groupStatus = 'failed';
            }else if(finalizeJob && finalizeJob.status === 'finished' && !jobs.some(j => j.status === 'queued')){
              groupStatus = 'finished';
            }
            const statusHtml = (() => {
              if(groupStatus === 'running') return 'Running <span class="loading-spinner"></span>';
              if(groupStatus === 'finished') return '<span class="status-success">Finished</span>';
              if(groupStatus === 'failed') return '<span class="status-failed">Failed</span>';
              return groupStatus;
            })();
            const startStr = earliestStart ? new Date(earliestStart).toLocaleString() : '';
            const finishStr = finishTime ? new Date(finishTime).toLocaleString() : '';

            const productLink = productUrl ? `<a href="${productUrl}" target="_blank">${productUrl}</a>` : '';

            headerTr.innerHTML = `
              <td></td>
              <td><span class="toggle">${collapsed ? '[+]' : '[-]'}</span> DB ID: ${dbId}<img src="uploads/${encodeURIComponent(firstJob.file)}" style="max-height:40px;margin-left:0.5rem;vertical-align:middle;" /> <button class="removeDbBtn" data-dbid="${dbId}" style="margin-left:0.5rem;">Remove</button> <button class="moveTopBtn" style="margin-left:0.5rem;">Move to top</button></td>
              <td></td>
              <td></td>
              <td></td>
              <td>${startStr}</td>
              <td>${finishStr}</td>
              <td>${statusHtml}</td>
              <td></td>
              <td></td>
              <td>${productLink}</td>
              <td></td>
            `;

            // Always display the header row even when group is collapsed
            // Only job rows should be hidden when collapsed
            tbody.appendChild(headerTr);
            headerTr.querySelector('.removeDbBtn')?.addEventListener('click', async ev => {
              ev.stopPropagation();
              await removeJobsByDbId(dbId);
            });
            groupTr.querySelector('.removeDbBtn').addEventListener('click', async ev => {
              ev.stopPropagation();
              await removeJobsByDbId(dbId);
            });
            const moveBtnHeader = headerTr.querySelector('.moveTopBtn');
            const moveBtnGroup = groupTr.querySelector('.moveTopBtn');
            [moveBtnHeader, moveBtnGroup].forEach(btn => {
              btn?.addEventListener('click', ev => {
                ev.stopPropagation();
                moveGroupToTop(dbId);
              });
            });
            groupTr.querySelector('.hideImageBtn').addEventListener('click', async ev => {
              ev.stopPropagation();
              const file = decodeURIComponent(ev.target.dataset.file || '');
              if(!file) return;
              try{
                await fetch('api/upload/hidden', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ name: file, hidden: true })
                });
                const opt = optionsDiv.querySelector(`.option[data-value="${CSS.escape(file)}"]`);
                opt?.remove();
                if(dropdown.dataset.value === file || dropdown.value === file){
                  selectedDiv.textContent = '-- choose --';
                  dropdown.dataset.value = '';
                  dropdown.value = '';
                  dropdown.dataset.id = '';
                  updatePreview('');
                  updateVariantUI('');
                }
              }catch(err){
                console.error('Failed to hide image', err);
              }
            });
            const toggleGroup = () => {
              const wasCollapsed = collapsedGroups.has(dbId);
              if(wasCollapsed){
                collapsedGroups.delete(dbId);
              }else{
                collapsedGroups.add(dbId);
              }
              const nowCollapsed = collapsedGroups.has(dbId);
              [groupTr, headerTr].forEach(row => {
                const t = row.querySelector('.toggle');
                if(t) t.textContent = nowCollapsed ? '[+]' : '[-]';
              });
              saveCollapsed();
              tbody.querySelectorAll(`tr[data-dbid="${dbId}"]:not(.group-header)`).forEach(r => {
                if(r !== groupTr) r.style.display = nowCollapsed ? 'none' : '';
              });
            };
            groupTr.addEventListener('click', e => {
              if(e.target.classList.contains('removeDbBtn') || e.target.classList.contains('hideImageBtn')) return;
              toggleGroup();
            });
            headerTr.addEventListener('click', e => {
              if(e.target.classList.contains('removeDbBtn')) return;
              toggleGroup();
            });
          }

          for(const job of jobs){
            const tr = document.createElement('tr');
          const jobLink = job.jobId ? `<a href="jobs.html?jobId=${job.jobId}" target="_blank">${job.jobId}</a>` : '';
          const dbLink = job.dbId
            ? `<a href="/Image.html?file=${encodeURIComponent(job.file)}" target="_blank">${job.dbId}</a>`
            : '';
          const statusHtml = (() => {
            if(job.status === 'running') return 'Running <span class="loading-spinner"></span>';
            if(job.status === 'finished') return '<span class="status-success">Finished</span>';
            if(job.status === 'failed' || job.status === 'error') return '<span class="status-failed">Failed</span>';
            return job.status;
          })();
          const startStr = job.startTime ? new Date(job.startTime).toLocaleString() : '';
          const finishStr = job.finishTime ? new Date(job.finishTime).toLocaleString() : '';
          const typeDisplay = job.type === 'upscale' ? 'upscale/backgroundRemove' : job.type;
          const resultText = job.type === 'colorIdentify'
            ? formatColorIdentifyResult(job.resultPath || '')
            : (job.resultPath || '');
          tr.innerHTML = `
            <td>${job.id}</td>
            <td>${dbLink}</td>
            <td>${typeDisplay}</td>
            <td>${job.location}</td>
            <td>${job.variant || ''}</td>
            <td>${startStr}</td>
            <td>${finishStr}</td>
            <td>${statusHtml}</td>
            <td>${jobLink}</td>
            <td>${resultText}</td>
            <td>${job.productUrl ? `<a href="${job.productUrl}" target="_blank">${job.productUrl}</a>` : ''}</td>
            <td><button data-id="${job.id}" class="removeBtn">Remove</button></td>
          `;
            tr.dataset.dbid = job.dbId || '';
            tr.dataset.id = job.id;
            tr.draggable = true;
            if(job.dbId && collapsedGroups.has(job.dbId)) tr.style.display = 'none';
            tbody.appendChild(tr);
            tr.querySelector('.removeBtn').addEventListener('click', async () => {
              await removeJob(job.id);
            });
          }
          queueOffset++;
        }
        if(groupEntries.length < 20) queueHasMore = false;
      }catch(e){
        console.error('Failed to load queue', e);
      }
      queueLoading = false;
      updateLoadMoreBtn();
    }
    const dropdown = document.getElementById('imageSelect');
    const selectedDiv = dropdown.querySelector('.selected');
    const optionsDiv = dropdown.querySelector('.options');
    const loadingDiv = optionsDiv.querySelector('.loading-more');

    let imgOffset = 0;
    let imgHasMore = true;
    let imgLoading = false;

    async function loadImages(reset=false){
      console.debug('[Queue UI] loadImages reset=' + reset);
      if(imgLoading) return;
      if(reset){
        imgOffset = 0;
        imgHasMore = true;
        optionsDiv.querySelectorAll('.option').forEach(o => o.remove());
        if(!dropdown.dataset.value){
          selectedDiv.textContent = '-- choose --';
        }
      }
      if(!imgHasMore) return;
      imgLoading = true;
      loadingDiv.style.display = 'block';
      try{
        const res = await fetch('api/upload/list?sessionId=' + encodeURIComponent(sessionId) + `&limit=20&offset=${imgOffset}&showHidden=0`);
        const files = await res.json();
        console.debug('[Queue UI] loaded images =>', files);
        files.forEach(f => {
          const item = document.createElement('div');
          item.className = 'option';
          item.dataset.value = f.name;
          item.dataset.id = f.id ?? '';
          const idx = (f.id !== null && f.id !== undefined) ? f.id : '';
          const upscaled = f.status && /upscaled/i.test(f.status);
          const label = upscaled ? '<span class="upscaled-label">[upscaled]</span>' : '';
          item.innerHTML = `<img src="uploads/${encodeURIComponent(f.name)}" /> <span>${idx}${label}</span>`;
          item.addEventListener('click', ev => {
            selectedDiv.innerHTML = `<img src="uploads/${encodeURIComponent(f.name)}" /> <span>${idx}${label}</span>`;
            dropdown.dataset.value = f.name;
            dropdown.dataset.id = f.id ?? '';
            optionsDiv.style.display = 'none';
            updatePreview(f.name);
            const type = document.getElementById('jobType').value;
            if(type === 'printify' || type === 'printifyPrice' || type === 'printifyTitleFix' || type === 'printifyFixMockups' || type === 'printifyFinalize' || type === 'all'){
              updateVariantUI(f.name);
            }
          });
          optionsDiv.appendChild(item);
        });
        imgOffset += files.length;
        if(files.length < 20) imgHasMore = false;
      }catch(e){
        console.error('Failed to load images', e);
      }
      imgLoading = false;
      loadingDiv.style.display = 'none';
    }

    const toggleOptions = () => {
      optionsDiv.style.display = optionsDiv.style.display === 'block' ? 'none' : 'block';
      if(optionsDiv.style.display === 'block' && optionsDiv.querySelectorAll('.option').length === 0){
        loadImages(true);
      }
    };

    selectedDiv.addEventListener('click', toggleOptions);
    selectedDiv.addEventListener('touchstart', e => {
      e.preventDefault();
      toggleOptions();
    });

    document.addEventListener('click', e => {
      if(!dropdown.contains(e.target)) optionsDiv.style.display = 'none';
    });
    document.addEventListener('touchstart', e => {
      if(!dropdown.contains(e.target)) optionsDiv.style.display = 'none';
    });

    optionsDiv.addEventListener('scroll', () => {
      if(optionsDiv.scrollTop + optionsDiv.clientHeight >= optionsDiv.scrollHeight - 5){
        loadImages();
      }
    });

    async function queueAllVariants(file, dbId, variants){
      const steps = ['upscale','colorIdentify','printify','printifyTitleFix','printifyFixMockups','printifyFinalize'];
      for(const variant of variants){
        for(const step of steps){
          await fetch('api/pipelineQueue', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ file, type: step, dbId, variant })
          });
        }
      }
      await loadQueue(true);
    }

    let sidebarOffset = 0;
    let sidebarHasMore = true;
    let sidebarLoading = false;
    const sidebarLoadMoreBtn = document.getElementById('sidebarLoadMoreBtn');

    function updateSidebarLoadMore(){
      if(!sidebarLoadMoreBtn) return;
      sidebarLoadMoreBtn.style.display = sidebarHasMore ? 'block' : 'none';
      sidebarLoadMoreBtn.disabled = sidebarLoading;
    }

    async function loadSidebarImages(reset=false){
      console.debug('[Queue UI] loadSidebarImages reset=' + reset);
      if(sidebarLoading) return;
      if(reset){
        sidebarOffset = 0;
        sidebarHasMore = true;
        document.getElementById('thumbnailContainer').innerHTML = '';
      }
      if(!sidebarHasMore){
        updateSidebarLoadMore();
        return;
      }
      sidebarLoading = true;
      updateSidebarLoadMore();
      document.getElementById('sidebarLoading').style.display = 'block';
      try{
        const res = await fetch('api/upload/list?sessionId=' + encodeURIComponent(sessionId) + `&limit=20&offset=${sidebarOffset}&showHidden=0`);
        const files = await res.json();
        const container = document.getElementById('thumbnailContainer');
        files.forEach(f => {
          const div = document.createElement('div');
          div.className = 'thumb-entry';
          const img = document.createElement('img');
          img.src = 'uploads/' + encodeURIComponent(f.name);
          div.appendChild(img);
          const id = f.id ?? '';
          const btnOrig = document.createElement('button');
          btnOrig.textContent = 'All - Original';
          btnOrig.addEventListener('click', async () => {
            await queueAllVariants(f.name, id, ['normal']);
            await hideImageUI(f.name, div);
          });
          const btnNobg = document.createElement('button');
          btnNobg.textContent = 'All - No BG';
          btnNobg.addEventListener('click', async () => {
            await queueAllVariants(f.name, id, ['nobg']);
            await hideImageUI(f.name, div);
          });
          const btnHide = document.createElement('button');
          btnHide.textContent = 'Hide';
          btnHide.addEventListener('click', async () => {
            await hideImageUI(f.name, div);
          });
          const btnContainer = document.createElement('div');
          btnContainer.appendChild(btnOrig);
          btnContainer.appendChild(btnNobg);
          btnContainer.appendChild(btnHide);
          div.appendChild(btnContainer);
          container.appendChild(div);
        });
        sidebarOffset += files.length;
        if(files.length < 20) sidebarHasMore = false;
      }catch(e){
        console.error('Failed to load sidebar images', e);
      }
      sidebarLoading = false;
      document.getElementById('sidebarLoading').style.display = 'none';
      updateSidebarLoadMore();
    }

    async function hideImageUI(file, entryDiv){
      try{
        await fetch('api/upload/hidden', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name: file, hidden: true })
        });
        const opt = optionsDiv.querySelector(`.option[data-value="${CSS.escape(file)}"]`);
        opt?.remove();
        if(dropdown.dataset.value === file || dropdown.value === file){
          selectedDiv.textContent = '-- choose --';
          dropdown.dataset.value = '';
          dropdown.value = '';
          dropdown.dataset.id = '';
          updatePreview('');
          updateVariantUI('');
        }
        entryDiv?.remove();
      }catch(err){
        console.error('Failed to hide image', err);
      }
    }

    function hideSidebar(){
      const sb = document.getElementById('imageSidebar');
      if(sb) sb.style.display = 'none';
    }

    function updatePreview(val){
      const img = document.getElementById('imagePreview');
      if(val){
        img.src = 'uploads/' + encodeURIComponent(val);
        img.style.display = '';
      }else{
        img.style.display = 'none';
      }
    }

    document.getElementById('jobType').addEventListener('change', () => {
      const type = document.getElementById('jobType').value;
      if(type === 'printify' || type === 'printifyPrice' || type === 'printifyTitleFix' || type === 'printifyFixMockups' || type === 'printifyFinalize' || type === 'all'){
        const sel = document.getElementById('imageSelect');
        updateVariantUI(sel.dataset.value || sel.value);
      } else {
        document.getElementById('variantChoice').style.display = 'none';
      }
    });

async function updateVariantUI(file){
  console.debug('[Queue UI] updateVariantUI for', file);
  const choiceDiv = document.getElementById('variantChoice');
  const normalRadio = document.getElementById('choiceQueueNormal');
  const nobgRadio = document.getElementById('choiceQueueNobg');
  const normalPath = document.getElementById('queueNormalPath');
  const nobgPath = document.getElementById('queueNobgPath');
  const type = document.getElementById('jobType').value;

  if(!file){
    choiceDiv.style.display = 'none';
    normalRadio.disabled = nobgRadio.disabled = true;
    normalPath.textContent = nobgPath.textContent = '';
    return;
  }
  try{
    const res = await fetch(`api/upscale/result?file=${encodeURIComponent(file)}`);
    const data = await res.json();
    const upPath = data.url || null;
    const nbPath = data.nobgUrl || (data.url && /(?:[_-](?:no)?[-_]?bg)/i.test(data.url) ? data.url : null);
    if(upPath){
      normalPath.textContent = upPath;
      normalRadio.disabled = false;
    }else{
      normalPath.textContent = type === 'all' ? '(will be generated)' : '(not found)';
      normalRadio.disabled = type !== 'all';
    }
    if(nbPath){
      nobgPath.textContent = nbPath;
      nobgRadio.disabled = false;
    }else{
      nobgPath.textContent = type === 'all' ? '(will be generated)' : '(not found)';
      nobgRadio.disabled = type !== 'all';
    }
    if(upPath || nbPath || type === 'all'){
      choiceDiv.style.display = '';
      if(nbPath){
        nobgRadio.checked = true;
      } else if(type === 'all'){
        nobgRadio.checked = true;
        normalRadio.checked = false;
      } else if(upPath){
        normalRadio.checked = true;
      } else {
        normalRadio.checked = nobgRadio.checked = false;
      }
    }else{
      choiceDiv.style.display = 'none';
    }
  }catch(e){
    console.error('Failed to check variant paths', e);
    choiceDiv.style.display = 'none';
  }
}

    document.getElementById('enqueueBtn').addEventListener('click', async () => {
      const selectEl = document.getElementById('imageSelect');
      const file = selectEl.dataset.value || selectEl.value;
      let dbId = selectEl.dataset.id;
      if(!dbId && selectEl.selectedOptions && selectEl.selectedOptions[0]){
        dbId = selectEl.selectedOptions[0].dataset.id || '';
      }
      const type = document.getElementById('jobType').value;
      const variantChoice = document.querySelector('input[name="queueVariant"]:checked');
      const variant = variantChoice ? variantChoice.value : null;
      const hideFlag = document.getElementById('hideWhenAdd').checked;
      const toTop = document.getElementById('queueTopCheckbox').checked;
      if(!file) return;
      console.debug('[Queue UI] enqueue clicked file=' + file + ' type=' + type + ' variant=' + variant);
      try{
        if(type === 'all'){
          const steps = ['upscale','colorIdentify','printify','printifyTitleFix','printifyFixMockups','printifyFinalize'];
          for(const step of steps){
            await fetch('api/pipelineQueue', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ file, type: step, dbId, variant, toTop })
            });
          }
        } else {
          await fetch('api/pipelineQueue', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ file, type, dbId, variant, toTop })
          });
          console.debug('[Queue UI] job enqueued');
        }
        if(hideFlag){
          try{
            await fetch('api/upload/hidden', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ name: file, hidden: true })
            });
            const opt = optionsDiv.querySelector(`.option[data-value="${CSS.escape(file)}"]`);
            opt?.remove();
            if(dropdown.dataset.value === file || dropdown.value === file){
              selectedDiv.textContent = '-- choose --';
              dropdown.dataset.value = '';
              dropdown.value = '';
              dropdown.dataset.id = '';
              updatePreview('');
              updateVariantUI('');
            }
          }catch(err){
            console.error('Failed to hide image', err);
          }
        }
        await loadQueue(true);
      }catch(e){
        console.error('Failed to enqueue job', e);
      }
    });

    document.getElementById('hideSelectedBtn').addEventListener('click', async () => {
      const selectEl = document.getElementById('imageSelect');
      const file = selectEl.dataset.value || selectEl.value;
      if(!file) return;
      try{
        await fetch('api/upload/hidden', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name: file, hidden: true })
        });
        const opt = optionsDiv.querySelector(`.option[data-value="${CSS.escape(file)}"]`);
        opt?.remove();
        selectedDiv.textContent = '-- choose --';
        dropdown.dataset.value = '';
        dropdown.value = '';
        dropdown.dataset.id = '';
        updatePreview('');
        updateVariantUI('');
      }catch(e){
        console.error('Failed to hide image', e);
      }
    });

    async function removeJob(id){
      console.debug('[Queue UI] removeJob', id);
      try{
        await fetch(`api/pipelineQueue/${id}`, { method: 'DELETE' });
        await loadQueue(true);
      }catch(e){
        console.error('Failed to remove job', e);
      }
    }

    async function removeJobsByDbId(dbId){
      console.debug('[Queue UI] removeJobsByDbId', dbId);
      try{
        await fetch(`api/pipelineQueue/db/${encodeURIComponent(dbId)}`, { method: 'DELETE' });
        collapsedGroups.delete(String(dbId));
        saveCollapsed();
        await loadQueue(true);
      }catch(e){
        console.error('Failed to remove jobs', e);
      }
    }

    function moveGroupToTop(dbId){
      console.debug('[Queue UI] moveGroupToTop', dbId);
      const tbodyEl = document.querySelector('#queueTable tbody');
      const rows = Array.from(tbodyEl.querySelectorAll(`tr[data-dbid="${CSS.escape(dbId)}"]`));
      if(rows.length === 0) return;
      const frag = document.createDocumentFragment();
      rows.forEach(r => frag.appendChild(r));
      const firstRow = tbodyEl.firstChild;
      tbodyEl.insertBefore(frag, firstRow);
      saveNewOrder();
    }

    async function loadQueueState(){
      try{
        const res = await fetch('api/pipelineQueue/state');
        const data = await res.json();
        const stateEl = document.getElementById('queueState');
        stateEl.textContent = data.paused ? 'Paused' : 'Running';
        stateEl.classList.toggle('queue-state-paused', data.paused);
        stateEl.classList.toggle('queue-state-running', !data.paused);
        document.getElementById('pauseBtn').textContent = data.paused ? 'Resume' : 'Pause';
      }catch(e){
        console.error('Failed to load queue state', e);
      }
    }

    document.getElementById('pauseBtn').addEventListener('click', async () => {
      const btn = document.getElementById('pauseBtn');
      const paused = btn.textContent === 'Resume';
      try{
        await fetch('api/pipelineQueue/' + (paused ? 'resume' : 'pause'), { method: 'POST' });
        await loadQueueState();
      }catch(e){
        console.error('Failed to toggle queue state', e);
      }
    });

    document.getElementById('stopAllBtn').addEventListener('click', async () => {
      if(!confirm('Stop all jobs?')) return;
      try{
        await fetch('api/pipelineQueue/stopAll', { method: 'POST' });
        await loadQueue(true);
      }catch(e){
        console.error('Failed to stop all jobs', e);
      }
    });

    document.getElementById('retryFailedBtn').addEventListener('click', async () => {
      try{
        await fetch('api/pipelineQueue/retryFailed', { method: 'POST' });
        await loadQueue(true);
      }catch(e){
        console.error('Failed to retry failed jobs', e);
      }
    });

    document.getElementById('removeFinishedBtn').addEventListener('click', async () => {
      if(!confirm('Remove all finished jobs?')) return;
      try{
        await fetch('api/pipelineQueue/finished', { method: 'DELETE' });
        await loadQueue(true);
      }catch(e){
        console.error('Failed to remove finished jobs', e);
      }
    });

    const autoRetryCheckbox = document.getElementById('autoRetryCheckbox');
    const retryCountdownSpan = document.getElementById('retryCountdown');
    const RETRY_INTERVAL = 300; // seconds
    let retryCountdown = RETRY_INTERVAL;

    function updateRetryCountdown(){
      if(!autoRetryCheckbox.checked){
        retryCountdownSpan.style.display = 'none';
        return;
      }
      retryCountdownSpan.style.display = 'inline';
      const m = Math.floor(retryCountdown / 60);
      const s = String(retryCountdown % 60).padStart(2, '0');
      retryCountdownSpan.textContent = `(${m}:${s})`;
      if(retryCountdown <= 0){
        retryCountdown = RETRY_INTERVAL;
        fetch('api/pipelineQueue/retryFailed', { method: 'POST' })
          .then(() => loadQueue(true))
          .catch(e => console.error('Failed to auto retry jobs', e));
      } else {
        retryCountdown--;
      }
    }

    autoRetryCheckbox.addEventListener('change', () => {
      retryCountdown = RETRY_INTERVAL;
      updateRetryCountdown();
    });

    const tbodyEl = document.querySelector('#queueTable tbody');
    let dragRow = null;
    tbodyEl.addEventListener('dragstart', ev => {
      const row = ev.target.closest('tr');
      if(row){
        dragRow = row;
        ev.dataTransfer.effectAllowed = 'move';
      }
    });
    tbodyEl.addEventListener('dragover', ev => {
      if(dragRow) ev.preventDefault();
    });
    tbodyEl.addEventListener('drop', ev => {
      ev.preventDefault();
      const target = ev.target.closest('tr');
      if(!dragRow || !target || dragRow === target){ dragRow = null; return; }
      if(dragRow.classList.contains('db-group') || dragRow.classList.contains('group-header')){
        const dbId = dragRow.dataset.dbid;
        const rows = Array.from(tbodyEl.querySelectorAll(`tr[data-dbid="${CSS.escape(dbId)}"]`));
        const frag = document.createDocumentFragment();
        rows.forEach(r => frag.appendChild(r));
        let insertBefore = target;
        if(!target.classList.contains('db-group') && !target.classList.contains('group-header')){
          insertBefore = tbodyEl.querySelector(`tr.db-group[data-dbid="${CSS.escape(target.dataset.dbid)}"]`) || target;
        }
        tbodyEl.insertBefore(frag, insertBefore);
      } else {
        if(target.classList.contains('db-group') || target.classList.contains('group-header')){ dragRow = null; return; }
        tbodyEl.insertBefore(dragRow, target);
      }
      dragRow = null;
      saveNewOrder();
    });
    tbodyEl.addEventListener('dragend', () => { dragRow = null; });

    async function saveNewOrder(){
      const ids = [];
      document.querySelectorAll('#queueTable tbody tr').forEach(tr => {
        if(tr.dataset.id) ids.push(tr.dataset.id);
      });
      if(ids.length === 0) return;
      try{
        await fetch('api/pipelineQueue/reorder', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ ids })
        });
      }catch(e){
        console.error('Failed to reorder queue', e);
      }
    }

    loadMoreBtn?.addEventListener('click', () => {
      loadQueue();
    });
    loadAllBtn?.addEventListener('click', async () => {
      while(queueHasMore){
        await loadQueue();
      }
    });

    setInterval(updateRetryCountdown, 1000);
    updateRetryCountdown();

    loadQueue(true);
    updateLoadMoreBtn();
    loadImages(true);
    loadSidebarImages(true);
    updateSidebarLoadMore();
    if(sidebarLoadMoreBtn){
      sidebarLoadMoreBtn.addEventListener('click', () => loadSidebarImages());
    }
    document.getElementById('imageSidebar').addEventListener('scroll', () => {
      const sb = document.getElementById('imageSidebar');
      if(sb.scrollTop + sb.clientHeight >= sb.scrollHeight - 5){
        loadSidebarImages();
      }
    });
    window.addEventListener('scroll', () => {
      if(window.innerHeight + window.scrollY >= document.body.offsetHeight - 5){
        loadQueue();
      }
    });
    document.getElementById('jobType').dispatchEvent(new Event('change'));
    loadQueueState();
    setInterval(() => { if(queueOffset === 0) loadQueue(true); loadQueueState(); }, 5000);
  </script>
    </div>
  </div>
</body>
</html>
